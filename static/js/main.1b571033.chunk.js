(this["webpackJsonpreact-patterns"]=this["webpackJsonpreact-patterns"]||[]).push([[0],{31:function(e,t,n){e.exports=n(44)},43:function(e,t,n){},44:function(e,t,n){"use strict";n.r(t);var a=n(0),o=n(1),r=n.n(o),c=n(26),s=n.n(c),l=n(27),p=n.n(l),i=n(28),u=n.n(i),m=n(10),b=n(13),d=n(3),h={};function j(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},h,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Overview"),Object(a.b)("p",null,"The project is created to experiment with different approaches to use\nReact and create a list of do's, dont's, problematic approaches and best\npractice in terms of performance, readability, extensibility and\nmaintainability."))}j.isMDXComponent=!0;var O=n(2),g=function(e){var t=r.a.useState(1),n=Object(O.a)(t,2),a=n[0],o=n[1];return[function(){return o(a+1)},e?a:1]},C=function(){var e=r.a.useState(),t=Object(O.a)(e,2)[1];return function(){return t({})}},f=n(17),v=function(e){var t=r.a.useRef(0);return t.current+=1,r.a.createElement("div",{style:Object(f.a)({},e.style,{borderStyle:"solid",borderWidth:3,borderColor:e.color,position:"relative",width:"70%",marginTop:4,marginBottom:4})},r.a.createElement("div",{style:{position:"absolute",right:0,top:0,background:"black",color:"white",fontFamily:"monospace",padding:2}},"Render count: ",t.current),e.children)},y=n(5),E=n(6),N=n(7),w=n(8),x=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"red"},"Child Class Component: ",this.props.value)}}]),n}(o.Component),k=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"shouldComponentUpdate",value:function(e){return e.value!==this.props.value}},{key:"render",value:function(){return r.a.createElement(v,{color:"red"},"Child Class Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.value)}}]),n}(o.Component),P=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"red"},"Child Class Component: ",this.props.obj.str)}}]),n}(o.Component),R=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"red"},"Child Class Component: ",this.props.obj.num)}}]),n}(o.Component),T=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"shouldComponentUpdate",value:function(e){return e.obj.str!==this.props.obj.str}},{key:"render",value:function(){return r.a.createElement(v,{color:"red"},"Child Class Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.obj.str)}}]),n}(o.Component),S=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"shouldComponentUpdate",value:function(e){return e.obj.num!==this.props.obj.num}},{key:"render",value:function(){return r.a.createElement(v,{color:"red"},"Child Class Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.obj.num)}}]),n}(o.Component),M=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"green"},"Child Pure Component: ",this.props.value)}}]),n}(o.PureComponent),F=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"green"},"Child Pure Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.value)}}]),n}(o.PureComponent),z=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"green"},"Child Pure Component: ",this.props.obj.str)}}]),n}(o.PureComponent),D=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return r.a.createElement(v,{color:"green"},"Child Pure Component: ",this.props.obj.num)}}]),n}(o.PureComponent),I=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"shouldComponentUpdate",value:function(e){return e.obj.str!==this.props.obj.str}},{key:"render",value:function(){return r.a.createElement(v,{color:"green"},"Child Pure Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.obj.str)}}]),n}(o.PureComponent),U=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"shouldComponentUpdate",value:function(e){return e.obj.num!==this.props.obj.num}},{key:"render",value:function(){return r.a.createElement(v,{color:"green"},"Child Pure Component ",r.a.createElement("strong",null,"Memoized"),": ",this.props.obj.num)}}]),n}(o.PureComponent),A=function(e){return r.a.createElement(v,{color:"blue"},"Child Function Component: ",e.value)},J=r.a.memo((function(e){return r.a.createElement(v,{color:"blue"},"Child Function Component ",r.a.createElement("strong",null,"Memoized"),": ",e.value)})),W=function(e){return r.a.createElement(v,{color:"blue"},"Child Function Component: ",e.obj.str)},q=function(e){return r.a.createElement(v,{color:"blue"},"Child Function Component: ",e.obj.num)},B=r.a.memo((function(e){return r.a.createElement(v,{color:"blue"},"Child Function Component ",r.a.createElement("strong",null,"Memoized"),": ",e.obj.str)}),(function(e,t){return e.obj.str===t.obj.str})),X=r.a.memo((function(e){return r.a.createElement(v,{color:"blue"},"Child Function Component ",r.a.createElement("strong",null,"Memoized"),": ",e.obj.num)}),(function(e,t){return e.obj.num===t.obj.num})),V=function(e){var t=g(e.changeProps),n=Object(O.a)(t,2),a=n[0],o=n[1];return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(r.a.Fragment,null,r.a.createElement(k,{value:o}),r.a.createElement(F,{value:o}),r.a.createElement(J,{value:o})):r.a.createElement(r.a.Fragment,null,r.a.createElement(x,{value:o}),r.a.createElement(M,{value:o}),r.a.createElement(A,{value:o})),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a()}},"Render example"))},L={};function H(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},L,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Components"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-component.html"}),Object(a.b)("inlineCode",{parentName:"a"},"React.Component"))," encapsulates ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/state-and-lifecycle.html"}),"State and Lifecycle"),"."),Object(a.b)("p",null,"There are few types o the components available in React:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Class Component")," - the component which extends ",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/react-api.html#reactcomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.Component"))," and uses OOP paradigms to handle state, properties, actions and manage component lifecycle. React component re-renders if the parent component got re-rendered even if no props were changed."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Pure Component")," - the ",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/react-api.html#reactpurecomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.PureComponent"))," is similar to the ",Object(a.b)("inlineCode",{parentName:"li"},"React.Component"),". The difference between them is that ",Object(a.b)("inlineCode",{parentName:"li"},"React.Component")," doesn\u2019t implement ",Object(a.b)("inlineCode",{parentName:"li"},"shouldComponentUpdate()"),", but ",Object(a.b)("inlineCode",{parentName:"li"},"React.PureComponent")," implements it with a ",Object(a.b)("strong",{parentName:"li"},"shallow prop and state comparison"),"."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Function Component")," - the ",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/components-and-props.html#function-and-class-components"}),Object(a.b)("inlineCode",{parentName:"a"},"React.FunctionComponent"))," is the component which takes props and renders them based on internal component logic.")),Object(a.b)("h3",null,"Regular components no props change"),Object(a.b)("p",null,"If there is no any additional work on the child components done the ",Object(a.b)("inlineCode",{parentName:"p"},"Class")," and ",Object(a.b)("inlineCode",{parentName:"p"},"Function")," children components will re-render even if ",Object(a.b)("strong",{parentName:"p"},"no properties have been changed"),"."),Object(a.b)("p",null,"As ",Object(a.b)("inlineCode",{parentName:"p"},"Pure")," component implements shallow comparison of the props out of the box, it won't re-render."),Object(a.b)(V,{isMemoized:!1,changeProps:!1,mdxType:"Components"}),Object(a.b)("h3",null,"Regular components props change"),Object(a.b)("p",null,"If ",Object(a.b)("strong",{parentName:"p"},"any prop has been changed")," on any of the component type: ",Object(a.b)("inlineCode",{parentName:"p"},"Class"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Pure"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Function")," all of them will re-render and this is ",Object(a.b)("strong",{parentName:"p"},"expected")," behavior."),Object(a.b)(V,{isMemoized:!1,changeProps:!0,mdxType:"Components"}),Object(a.b)("h3",null,"Memoized components no props change"),Object(a.b)("p",null,'Components should be "memoized" to prevent re-rendering when no props have been changed.'),Object(a.b)("p",null,'The "memoziation" techniques described in the corresponding section of each component type.'),Object(a.b)("p",null,"The only ",Object(a.b)("inlineCode",{parentName:"p"},"Pure")," component has this functionality out of the box and no additional work for such component required."),Object(a.b)(V,{isMemoized:!0,changeProps:!1,mdxType:"Components"}),Object(a.b)("h3",null,"Memoized components props change"),Object(a.b)("p",null,"If ",Object(a.b)("strong",{parentName:"p"},"any prop has been changed")," on any of the component type: ",Object(a.b)("inlineCode",{parentName:"p"},"Class"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Pure"),", ",Object(a.b)("inlineCode",{parentName:"p"},"Function"),' all of them will re-render even if they are "memoized" and this is ',Object(a.b)("strong",{parentName:"p"},"expected")," behavior."),Object(a.b)(V,{isMemoized:!0,changeProps:!0,mdxType:"Components"}))}H.isMDXComponent=!0;var _=function(e){var t=g(e.changeProps),n=Object(O.a)(t,2),a=n[0],o=n[1];return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(k,{value:o}):r.a.createElement(x,{value:o}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:a},"Render example"))},$=function(e){var t={num:1,str:"hello"},n=Object(o.useState)(t),a=Object(O.a)(n,2),c=a[0],s=a[1],l=e.changeProps?function(){return s((function(e){return{num:e.num,str:"".concat(t.str," ").concat(Math.round(100*Math.random()))}}))}:function(){return s((function(e){return{num:e.num+1,str:e.str}}))},p=e.changeProps?"str property changes, num remains unchanged: { num: ".concat(c.num,", str: ").concat(c.str," }"):"num property changes, str remains unchanged: { num: ".concat(c.num,", str: ").concat(c.str," }");return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(r.a.Fragment,null,r.a.createElement(S,{obj:c}),r.a.createElement(T,{obj:c})):r.a.createElement(r.a.Fragment,null,r.a.createElement(R,{obj:c}),r.a.createElement(P,{obj:c})),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return l()}},"Render example"),"\xa0",r.a.createElement("span",null,p))},G={};function K(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},G,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Class Component"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Class Component")," - the component which extends ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-api.html#reactcomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.Component"))," and uses OOP paradigms to handle state, properties, actions and manage component lifecycle. React component re-renders if the parent component got re-rendered even if no props were changed."),Object(a.b)("h3",null,"Regular Component - Plain props"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponent extends Component<TValue> {\n  render() {\n    // if parent component updates this component will be re-rendered \ud83d\udca3,\n    // no matter if the props have been changed or not.\n    return (\n      <RenderCounter color="red">\n        Child Class Component: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(_,{isMemoized:!1,mdxType:"PlainPropsClassComponent"}),Object(a.b)("h3",null,"Solution 1: Override ",Object(a.b)("inlineCode",{parentName:"h3"},"shouldComponentUpdate()")," lifecycle method"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponentMemoized extends Component<TValue> {\n  // \u2705 place the logic to detect if component should update or not.\n  shouldComponentUpdate(nextProps: Readonly<TValue>) {\n    // \ud83d\udca1 the logic here might become very complicated,\n    // make sure you split components to the small or\n    // consider using Pure or Function components.\n    return nextProps.value !== this.props.value;\n  }\n\n  // \u2705 the component re-renders only if props have been changed.\n  render() {\n    return (\n      <RenderCounter color="red">\n        Child Class Component <strong>Memoized</strong>: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(_,{isMemoized:!0,changeProps:!1,mdxType:"PlainPropsClassComponent"}),Object(a.b)("p",null,"and it re-renders as expected, when props have been changes."),Object(a.b)(_,{isMemoized:!0,changeProps:!0,mdxType:"PlainPropsClassComponent"}),Object(a.b)("h3",null,"Solution 2: Use Pure Component"),Object(a.b)("p",null,"Consider using Pure Component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponent extends PureComponent<TValue> {\n  // `Pure` component implements `shouldComponentUpdate()` with a shallow prop and state comparison.\n  // That means no additional changes needed for the plain props.\n  // \u2705 Component does not re-render if parent component re-renders\n  // but the props have not been changed.\n  render() {\n    return (\n      <RenderCounter color="green">\n        Child Pure Component: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)("hr",null),Object(a.b)("h3",null,"Regular Component - Object props"),Object(a.b)("p",null,"Passing objects as properties to the component are dangerous in terms of causing not wanted re-rendering.\nIf component needs to work only with subset of the object properties and none of them being changed,\nthe component still might re-render if any of the other property has changed."),Object(a.b)("p",null,"Also, even if developer created the object and passes it as a parameter to the component,\nit doesn't prevent other developers to add their own properties to the same object without\neven knowing that it might have negative impact on re-rendering some other not related component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"export type TObjectProps = {\n  obj: TObjectValue;\n};\n\nexport type TObjectValue = {\n  num: number;\n  str: string;\n};\n")),Object(a.b)("p",null,"The component takes object properties as defined above:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponentWithObjectProps extends Component<\n  TObjectProps\n> {\n  render() {\n    // The component only works with \u2705 obj.str property and ignores \u2705 obj.num\n    // If parent component doesn\'t change the \u2705 obj.str, but changes \u26d4 obj.num\n    // this component will still re-render \ud83d\udca3\n    return (\n      <RenderCounter color="red">\n        Child Class Component: {this.props.obj.str}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)("p",null,"When parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.num")," and doesn't change ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str"),", the component\nstill re-renders."),Object(a.b)($,{isMemoized:!1,mdxType:"ObjectPropsClassComponent"}),Object(a.b)("h3",null,"Solution 1: Use plain props"),Object(a.b)("p",null,"The best solution is to use plain props and pass primitive values to the component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponentWithObjectProps extends Component<{\n  str: string;\n}> {\n  // \u2757 even is you use plain props, make sule you also override shouldComponentUpdate()\n  // othervise force update will trigger re-rendering.\n  shouldComponentUpdate(nextProps: Readonly<{ str: string }>) {\n    return nextProps.str !== this.props.str;\n  }\n\n  render() {\n    // \u2705 No object which can impact re-rendering\n    return (\n      <RenderCounter color="red">\n        Child Class Component: {this.props.str}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)("h3",null,"Solution 2: Override ",Object(a.b)("inlineCode",{parentName:"h3"},"shouldComponentUpdate()")," lifecycle method"),Object(a.b)("p",null,"When parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.num")," and doesn't change ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str"),", the component\n",Object(a.b)("strong",{parentName:"p"},"does not")," re-render."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildClassComponentWithObjectPropsMemoized extends Component<\n  TObjectProps\n> {\n  shouldComponentUpdate(nextProps: Readonly<TObjectProps>) {\n    // \u2705 Make sure you cover scenario, when other developer\n    // could potentially add other fields to the props object\n    return nextProps.obj.str !== this.props.obj.str;\n  }\n\n  render() {\n    return (\n      <RenderCounter color="red">\n        Child Class Component <strong>Memoized</strong>: {this.props.obj.str}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)($,{isMemoized:!0,changeProps:!1,mdxType:"ObjectPropsClassComponent"}),Object(a.b)("p",null,"but when parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str")," re-rendering happens, as expected:"),Object(a.b)($,{isMemoized:!0,changeProps:!0,mdxType:"ObjectPropsClassComponent"}))}K.isMDXComponent=!0;var Y=function(e){var t=g(e.changeProps),n=Object(O.a)(t,2),a=n[0],o=n[1];return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(F,{value:o}):r.a.createElement(M,{value:o}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:a},"Render example"))},Q=function(e){var t={num:1,str:"hello"},n=Object(o.useState)(t),a=Object(O.a)(n,2),c=a[0],s=a[1],l=e.changeProps?function(){return s((function(e){return{num:e.num,str:"".concat(t.str," ").concat(Math.round(100*Math.random()))}}))}:function(){return s((function(e){return{num:e.num+1,str:e.str}}))},p=e.changeProps?"str property changes, num remains unchanged: { num: ".concat(c.num,", str: ").concat(c.str," }"):"num property changes, str remains unchanged: { num: ".concat(c.num,", str: ").concat(c.str," }");return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(r.a.Fragment,null,r.a.createElement(U,{obj:c}),r.a.createElement(I,{obj:c})):r.a.createElement(r.a.Fragment,null,r.a.createElement(D,{obj:c}),r.a.createElement(z,{obj:c})),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return l()}},"Render example"),"\xa0",r.a.createElement("span",null,p))},Z={};function ee(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},Z,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Pure Component"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Pure Component")," - the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-api.html#reactpurecomponent"}),Object(a.b)("inlineCode",{parentName:"a"},"React.PureComponent"))," is similar to the ",Object(a.b)("inlineCode",{parentName:"p"},"React.Component"),". The difference between them is that ",Object(a.b)("inlineCode",{parentName:"p"},"React.Component")," doesn\u2019t implement ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()"),", but ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent")," implements it with a ",Object(a.b)("strong",{parentName:"p"},"shallow prop and state comparison"),"."),Object(a.b)("p",null,"If your React component\u2019s ",Object(a.b)("inlineCode",{parentName:"p"},"render()")," function renders the same result given the same props and state, you can use ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent")," for a performance boost in some cases."),Object(a.b)("h3",null,"Regular Component - Plain props"),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Pure")," component implements ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()")," with a ",Object(a.b)("strong",{parentName:"p"},"shallow prop and state comparison"),".\nThat means no additional changes needed for the plain props."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponent extends PureComponent<TValue> {\n  // `Pure` component implements `shouldComponentUpdate()` with a **shallow prop and state comparison**.\n  // That means no additional changes needed for the plain props.\n  // \u2705 Component does not re-render if parent component re-renders\n  // but the props have not been changed.\n  render() {\n    return (\n      <RenderCounter color="green">\n        Child Pure Component: {this.props.value}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(Y,{isMemoized:!1,mdxType:"PlainPropsPureComponent"}),Object(a.b)("p",null,"and it re-renders as expected, when props have been changes."),Object(a.b)(Y,{isMemoized:!0,changeProps:!0,mdxType:"PlainPropsPureComponent"}),Object(a.b)("hr",null),Object(a.b)("h3",null,"Regular Component - Object props"),Object(a.b)("p",null,"Passing objects as properties to the component are dangerous in terms of causing not wanted re-rendering.\nIf component needs to work only with subset of the object properties and none of them being changed,\nthe component still might re-render if any of the other property has changed."),Object(a.b)("p",null,"Also, even if developer created the object and passes it as a parameter to the component,\nit doesn't prevent other developers to add their own properties to the same object without\neven knowing that it might have negative impact on re-rendering some other not related component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"export type TObjectProps = {\n  obj: TObjectValue;\n};\n\nexport type TObjectValue = {\n  num: number;\n  str: string;\n};\n")),Object(a.b)("p",null,"The component takes object properties as defined above:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponentWithObjectProps extends PureComponent<\n  TObjectProps\n> {\n  render() {\n    // The component only works with \u2705 obj.str property and ignores \u2705 obj.num\n    // If parent component doesn\'t change the \u2705 obj.str, but changes \u26d4 obj.num\n    // this component will still re-render \ud83d\udca3\n    return (\n      <RenderCounter color="red">\n        Child Pure Component: {this.props.obj.str}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)("p",null,"When parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.num")," and doesn't change ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str"),", the component\nstill re-renders. This happens, because ",Object(a.b)("inlineCode",{parentName:"p"},"PureComponent")," does a ",Object(a.b)("strong",{parentName:"p"},"shallow")," comparison."),Object(a.b)(Q,{isMemoized:!1,mdxType:"ObjectPropsPureComponent"}),Object(a.b)("h3",null,"Solution 1: Use plain props"),Object(a.b)("p",null,"The best solution is to use plain props and pass primitive values to the component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponentWithObjectProps extends PureComponent<{\n  str: string;\n}> {\n  render() {\n    // \u2705 No object which can impact re-rendering\n    return (\n      <RenderCounter color="red">\n        Child Pure Component: {this.props.str}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)("h3",null,"Solution 2: Override ",Object(a.b)("inlineCode",{parentName:"h3"},"shouldComponentUpdate()")," lifecycle method"),Object(a.b)("p",null,"When parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.num")," and doesn't change ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str"),", the component\n",Object(a.b)("strong",{parentName:"p"},"does not")," re-render."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export class ChildPureComponentWithObjectPropsMemoized extends PureComponent<\n  TObjectProps\n> {\n  shouldComponentUpdate(nextProps: Readonly<TObjectProps>) {\n    // \u2705 Make sure you cover scenario, when other developer\n    // could potentially add other fields to the props object\n    return nextProps.obj.str !== this.props.obj.str;\n  }\n\n  render() {\n    return (\n      <RenderCounter color="red">\n        Child Pure Component <strong>Memoized</strong>: {this.props.obj.str}\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(Q,{isMemoized:!0,changeProps:!1,mdxType:"ObjectPropsPureComponent"}),Object(a.b)("p",null,"but when parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str")," re-rendering happens, as expected:"),Object(a.b)(Q,{isMemoized:!0,changeProps:!0,mdxType:"ObjectPropsPureComponent"}))}ee.isMDXComponent=!0;var te=function(e){var t=g(e.changeProps),n=Object(O.a)(t,2),a=n[0],o=n[1];return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(J,{value:o}):r.a.createElement(A,{value:o}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:a},"Render example"))},ne=function(e){var t={num:1,str:"hello"},n=Object(o.useState)(t),a=Object(O.a)(n,2),c=a[0],s=a[1],l=e.changeProps?function(){return s((function(e){return{num:e.num,str:"".concat(t.str," ").concat(Math.round(100*Math.random()))}}))}:function(){return s((function(e){return{num:e.num+1,str:e.str}}))},p=e.changeProps?"str property changes, num remains unchanged: { num: ".concat(c.num,", str: ").concat(c.str," }"):"num property changes, str remains unchanged: { num: ".concat(c.num,", str: ").concat(c.str," }");return r.a.createElement(v,{color:"black"},r.a.createElement("p",null,"Container"),e.isMemoized?r.a.createElement(r.a.Fragment,null,r.a.createElement(X,{obj:c}),r.a.createElement(B,{obj:c})):r.a.createElement(r.a.Fragment,null,r.a.createElement(q,{obj:c}),r.a.createElement(W,{obj:c})),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return l()}},"Render example"),"\xa0",r.a.createElement("span",null,p))},ae={};function oe(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},ae,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Function Component"),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Function Component")," - the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/components-and-props.html#function-and-class-components"}),Object(a.b)("inlineCode",{parentName:"a"},"React.FunctionComponent"))," is the component which takes props and renders them based on internal component logic."),Object(a.b)("h3",null,"Regular Component - Plain props"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'// Component is not memoized the parent re-render triggers this component to re-render \ud83d\udca3 too\n// even if no props have been changed.\nexport const ChildFunctionComponent: FunctionComponent<TValue> = (\n  props: TValue\n) => {\n  return (\n    <RenderCounter color="blue">\n      Child Function Component: {props.value}\n    </RenderCounter>\n  );\n};\n')),Object(a.b)(te,{isMemoized:!1,mdxType:"PlainPropsFunctionComponent"}),Object(a.b)("h3",null,"Solution: Memoize component with React.memo()"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/react-api.html#reactmemo"}),Object(a.b)("inlineCode",{parentName:"a"},"React.memo"))," is a higher order component. It\u2019s similar to ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent")," but for function components instead of classes."),Object(a.b)("p",null,"If your function component renders the same result given the same props, you can wrap it in a call to ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," only affects props changes. If your function component wrapped in ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo")," has a ",Object(a.b)("inlineCode",{parentName:"p"},"useState")," or ",Object(a.b)("inlineCode",{parentName:"p"},"useContext")," Hook in its implementation, it will still rerender when state or context change."),Object(a.b)("p",null,"By default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'// \u2705 Memoize component to make sure it doesn\'t re-render, when props have been changed.\nexport const ChildFunctionComponentMemoized: FunctionComponent<TValue> = React.memo<\n  FunctionComponent<TValue>\n>((props: TValue) => {\n  return (\n    <RenderCounter color="blue">\n      Child Function Component <strong>Memoized</strong>: {props.value}\n    </RenderCounter>\n  );\n});\n')),Object(a.b)(te,{isMemoized:!0,changeProps:!1,mdxType:"PlainPropsFunctionComponent"}),Object(a.b)("p",null,"and it re-renders as expected, when props have been changes."),Object(a.b)(te,{isMemoized:!0,changeProps:!0,mdxType:"PlainPropsFunctionComponent"}),Object(a.b)("hr",null),Object(a.b)("h3",null,"Regular Component - Object props"),Object(a.b)("p",null,"Passing objects as properties to the component are dangerous in terms of causing not wanted re-rendering.\nIf component needs to work only with subset of the object properties and none of them being changed,\nthe component still might re-render if any of the other property has changed."),Object(a.b)("p",null,"Also, even if developer created the object and passes it as a parameter to the component,\nit doesn't prevent other developers to add their own properties to the same object without\neven knowing that it might have negative impact on re-rendering some other not related component."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"export type TObjectProps = {\n  obj: TObjectValue;\n};\n\nexport type TObjectValue = {\n  num: number;\n  str: string;\n};\n")),Object(a.b)("p",null,"The component takes object properties as defined above:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export const ChildFunctionComponentWithObjectProps: FunctionComponent<TObjectProps> = (\n  props: TObjectProps\n) => {\n  // The component only works with \u2705 obj.str property and ignores \u2705 obj.num\n  // If parent component doesn\'t change the \u2705 obj.str, but changes \u26d4 obj.num\n  // this component will still re-render \ud83d\udca3\n  return (\n    <RenderCounter color="blue">\n      Child Function Component: {props.obj.str}\n    </RenderCounter>\n  );\n};\n')),Object(a.b)("p",null,"When parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.num")," and doesn't change ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str"),", the component\nstill re-renders."),Object(a.b)("h3",null,"Solution 1: Use plain props"),Object(a.b)("p",null,"The best solution is to use plain props and pass primitive values to the component.\nDon't forget to memoize the props value."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'// \u2705 Memoize component to make sure it doesn\'t re-render, when props have been changed.\nexport const ChildFunctionComponentMemoized: FunctionComponent<{\n  str: strings;\n}> = React.memo<FunctionComponent<{ str: strings }>>(\n  (props: { str: strings }) => {\n    return (\n      <RenderCounter color="blue">\n        Child Function Component <strong>Memoized</strong>: {props.str}\n      </RenderCounter>\n    );\n  }\n);\n')),Object(a.b)("h2",null,"Solution 2: Add comparison function"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'export const ChildFunctionComponentWithObjectPropsMemoized: FunctionComponent<TObjectProps> = React.memo<\n  FunctionComponent<TObjectProps>\n>(\n  (props: TObjectProps) => {\n    return (\n      <RenderCounter color="blue">\n        Child Function Component <strong>Memoized</strong>: {props.obj.str}\n      </RenderCounter>\n    );\n  },\n  // \u2705 Add the properties comparison function.\n  (prevProps: Readonly<TObjectProps>, nextProps: Readonly<TObjectProps>) => {\n    return prevProps.obj.str === nextProps.obj.str;\n  }\n);\n')),Object(a.b)(ne,{isMemoized:!0,changeProps:!1,mdxType:"ObjectPropsFunctionComponent"}),Object(a.b)("p",null,"but when parent component changes ",Object(a.b)("inlineCode",{parentName:"p"},"obj.str")," re-rendering happens, as expected:"),Object(a.b)(ne,{isMemoized:!0,changeProps:!0,mdxType:"ObjectPropsFunctionComponent"}))}oe.isMDXComponent=!0;var re=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"strMethodComponent",value:function(){var e=this.props.str;return o.createElement(v,{color:"blue"},o.createElement("p",null,o.createElement("i",null,"str")," is ",e))}},{key:"numMethodComponent",value:function(){var e=this.props.num;return o.createElement(v,{color:"red"},o.createElement("p",null,o.createElement("i",null,"num")," is ",e))}},{key:"render",value:function(){return o.createElement(v,{color:"yellow"},o.createElement("div",null,this.strMethodComponent(),this.numMethodComponent()))}}]),n}(o.PureComponent),ce=o.memo((function(e){var t=e.str;return o.createElement(v,{color:"blue"},o.createElement("p",null,o.createElement("i",null,"str")," is ",t))})),se=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return o.createElement(v,{color:"red"},o.createElement("p",null,o.createElement("i",null,"num")," is ",this.props.num))}}]),n}(o.PureComponent),le=function(e){Object(w.a)(n,e);var t=Object(N.a)(n);function n(){return Object(y.a)(this,n),t.apply(this,arguments)}return Object(E.a)(n,[{key:"render",value:function(){return o.createElement(v,{color:"yellow"},o.createElement("div",null,o.createElement(ce,{str:this.props.str}),o.createElement(se,{num:this.props.num})))}}]),n}(o.PureComponent),pe=function(e){var t=e.isCorrect,n=o.useState(1),a=Object(O.a)(n,2),r=a[0],c=a[1],s=o.useState("1"),l=Object(O.a)(s,2),p=l[0],i=l[1];return o.createElement("div",null,t?o.createElement(le,{num:r,str:p}):o.createElement(re,{num:r,str:p}),o.createElement("button",{onClick:function(){return i((function(e){return"".concat(parseInt(e)+1)}))}},"Update `str`"),o.createElement("button",{onClick:function(){return c((function(e){return e+1}))}},"Update `num`"))},ie={};function ue(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},ie,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Method Component"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Note, the ",Object(a.b)("inlineCode",{parentName:"p"},"Method Component")," term is not an industry defined term.\nThat's how we call it describe the component which get returned from\nthe method of class.")),Object(a.b)("p",null,"Method Component is a component which was implemented as a ",Object(a.b)("strong",{parentName:"p"},"method of Class Component"),".\nImplementing components this way will cause several issues:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Hard to maintain, components become tightly coupled"),Object(a.b)("li",{parentName:"ul"},"Hard to control re-rendering conditions"),Object(a.b)("li",{parentName:"ul"},"Hard to reuse such components"),Object(a.b)("li",{parentName:"ul"},"Idiomatically React is functional and the approach is rather OOP"),Object(a.b)("li",{parentName:"ul"},"Potentially may cause hooks related bugs (",Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://kentcdodds.com/blog/dont-call-a-react-function-component"}),"https://kentcdodds.com/blog/dont-call-a-react-function-component"),")")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/tutorial/tutorial.html"}),"React Tutorials")," ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/tutorial/tutorial.html#passing-data-through-props"}),"illustrate this approach"),"\nin the examples with the ",Object(a.b)("inlineCode",{parentName:"p"},"renderSquare()")," method. We recommended to use it only if there is strong use case for such a usage.\nOtherwise try to avoid this approach, because of the reasons described in this article.\nReact Tutorials mentions that it should be factored out in the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/tutorial/tutorial.html#wrapping-up"}),"Wrapping Up")," section.")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'interface IClassComponentWithMethodComponentsProps {\n  str: string;\n  num: number;\n}\nexport class ClassComponentWithMethodComponents extends React.PureComponent<\n  IClassComponentWithMethodComponentsProps\n> {\n  private strMethodComponent() {\n    const { str } = this.props;\n    return (\n      <RenderCounter color="blue">\n        <p>\n          <i>str</i> is {str}\n        </p>\n      </RenderCounter>\n    );\n  }\n  private numMethodComponent() {\n    const { num } = this.props;\n    return (\n      <RenderCounter color="red">\n        <p>\n          <i>num</i> is {num}\n        </p>\n      </RenderCounter>\n    );\n  }\n\n  render() {\n    return (\n      <RenderCounter color="yellow">\n        <div>\n          {this.strMethodComponent()}\n          {this.numMethodComponent()}\n        </div>\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(pe,{mdxType:"Wrapper"}),Object(a.b)("h3",null,"Solution: Separated Components"),Object(a.b)("p",null,"Every component has its scope and depends only on required props.\nIt allows us to easily refactor/remove a component and specify re-render conditions\nfor each component separately using ",Object(a.b)("inlineCode",{parentName:"p"},"React.PureComponent"),", ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()")," or ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo()")),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),'interface IStrComponentProps {\n  str: string;\n}\nconst StrComponent = React.memo(({ str }: IStrComponentProps) => (\n  <RenderCounter color="blue">\n    <p>\n      <i>str</i> is {str}\n    </p>\n  </RenderCounter>\n));\n\ninterface INumComponentProps {\n  num: number;\n}\nclass NumComponent extends React.PureComponent<INumComponentProps> {\n  render() {\n    return (\n      <RenderCounter color="red">\n        <p>\n          <i>num</i> is {this.props.num}\n        </p>\n      </RenderCounter>\n    );\n  }\n}\n\ninterface IClassComponentProps {\n  str: string;\n  num: number;\n}\nexport class ClassComponent extends React.PureComponent<IClassComponentProps> {\n  render() {\n    return (\n      <RenderCounter color="yellow">\n        <div>\n          <StrComponent str={this.props.str} />\n          <NumComponent num={this.props.num} />\n        </div>\n      </RenderCounter>\n    );\n  }\n}\n')),Object(a.b)(pe,{isCorrect:!0,mdxType:"Wrapper"}))}ue.isMDXComponent=!0;var me=r.a.memo((function(e){return r.a.createElement(v,{color:e.color},"A component wrapped with ",r.a.createElement("code",null,"React.memo()")," with"," ",e.memoized?"memoized":"not memoized"," callback.")})),be=function(){var e=r.a.useCallback((function(){}),[]),t=C();return r.a.createElement(r.a.Fragment,null,r.a.createElement(me,{color:"green",onNoop:e,memoized:!0}),r.a.createElement(me,{color:"red",onNoop:function(){},memoized:!1}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:t},"Render example"))},de=function(){return r.a.createElement(v,{color:"red"},"A usual component")},he=r.a.memo((function(){return r.a.createElement(v,{color:"green"},"A component wrapped with ",r.a.createElement("code",null,"React.memo()"))})),je=function(){var e=r.a.useCallback((function(){}),[]),t=C();return r.a.createElement(r.a.Fragment,null,r.a.createElement(de,{onNoop:e}),r.a.createElement(he,{onNoop:e}),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:t},"Render example"))},Oe={};function ge(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},Oe,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Hooks"),Object(a.b)("h3",null,"Use ",Object(a.b)("inlineCode",{parentName:"h3"},"useCallback()")," hook carefully, if you have a control on you children components"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"In React code reviews, I see a lot of unnecessary usage of the ",Object(a.b)("inlineCode",{parentName:"p"},"useCallback()")," hook.\nCommon misconception is that you need to use it for ",Object(a.b)("em",{parentName:"p"},"any")," callback passed as a prop to a child component.\nHowever, not true: it's a perf optimization only for when child component is pure/memo'd.")),Object(a.b)("p",null,"Source: ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://twitter.com/spikebrehm/status/1233038597734965248"}),"Twitter")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"useCallback()")," hooks allows to keep references to created functions inside components, but it should be used only for callbacks are passed to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),", ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo()"),")."),Object(a.b)("p",null,"By default all React components do not use any update blockers, so there is no sense to force use ",Object(a.b)("inlineCode",{parentName:"p"},"useCallback"),"\nfor every callback in your application:"),Object(a.b)(je,{mdxType:"UselessUseCallback"}),Object(a.b)("p",null,"But, it makes sense to pass memoized callbacks to components that handle reference equality:"),Object(a.b)(be,{mdxType:"ProperUseCallback"}),Object(a.b)("h3",null,"Children are out of your control"),Object(a.b)("p",null,"On the other hand, if you ",Object(a.b)("strong",{parentName:"p"},"don't know what children component might be"),", it is worth to wrap your functions\nwith ",Object(a.b)("inlineCode",{parentName:"p"},"useCallback()")," hook. The operation itself is cheap and can prevent unwanted perf issues."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"But if you don't \"own\" the child component, isn't it safer to memo it when you pass it on?\nIf your function is new on each render, you might break some perf of your consumers.\ne.g. shouldComponentUpdate / useEffect")),Object(a.b)("p",null,"Source: ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://twitter.com/sag1v/status/1233127420879949826?s=20"}),"Twitter")))}ge.isMDXComponent=!0;var Ce=n(16),fe=n.n(Ce),ve=n(19),ye=function(e){return new Promise((function(t){return setTimeout(t,e)}))},Ee=function(e){var t=Object(o.useState)("initial data"),n=Object(O.a)(t,2),a=n[0],c=n[1];return Object(o.useEffect)((function(){(function(){var t=Object(ve.a)(fe.a.mark((function t(){return fe.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,ye(1e4);case 2:c(e.updatedData);case 3:case"end":return t.stop()}}),t)})));return function(){return t.apply(this,arguments)}})()()}),[e.updatedData]),r.a.createElement(v,{color:"red"},r.a.createElement("div",null,a))},Ne=function(e){var t=Object(o.useState)("initial data"),n=Object(O.a)(t,2),a=n[0],c=n[1];return Object(o.useEffect)((function(){var t=!1;return function(){var n=Object(ve.a)(fe.a.mark((function n(){return fe.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,ye(1e4);case 2:if(!t){n.next=4;break}return n.abrupt("return");case 4:c(e.updatedData);case 5:case"end":return n.stop()}}),n)})));return function(){return n.apply(this,arguments)}}()(),function(){t=!0}}),[e.updatedData]),r.a.createElement(v,{color:"green"},r.a.createElement("div",null,a))},we=function(){var e=Object(o.useState)(1),t=Object(O.a)(e,2),n=t[0],a=t[1],c=Object(o.useState)("updated data"),s=Object(O.a)(c,2),l=s[0],p=s[1];return r.a.createElement(v,{color:"black"},r.a.createElement(Ee,{updatedData:l}),r.a.createElement("button",{onClick:function(){a(n++),p("updated data ".concat(n))}},"Re-render component"))},xe=function(){var e=Object(o.useState)(1),t=Object(O.a)(e,2),n=t[0],a=t[1],c=Object(o.useState)("updated data"),s=Object(O.a)(c,2),l=s[0],p=s[1];return r.a.createElement(v,{color:"black"},r.a.createElement(Ne,{updatedData:l}),r.a.createElement("button",{onClick:function(){a(n++),p("updated data ".concat(n))}},"Re-render component"))},ke={};function Pe(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},ke,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"useEffect async"),Object(a.b)("p",null,"When use ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/hooks-reference.html#useeffect"}),Object(a.b)("inlineCode",{parentName:"a"},"useEffect()"))," hook with async operation inside,"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"const UseEffectAsync: FC<TData> = (props: TData) => {\n  let [data, setData] = useState('initial data');\n\n  useEffect(() => {\n    const asyncOp = async () => {\n      await sleep(10 * 1000);\n\n      setData(props.updatedData);\n    };\n    asyncOp();\n  }, [props.updatedData]);\n\n  return (\n    <RenderCounter color=\"red\">\n      <div>{data}</div>\n    </RenderCounter>\n  );\n};\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note:"),' wait 10 seconds and look how data get updated. After that click few times on "re-render" button\nand look how data will start update sequentially and render each data change, when promise resolves.')),Object(a.b)(we,{mdxType:"UseEffectAsyncExample"}),Object(a.b)("p",null,"make sure you ",Object(a.b)("strong",{parentName:"p"},"always")," return cleanup function, which will cancel/ignore function:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"const UseEffectAsyncWithCleanup: FC<TData> = (props: TData) => {\n  let [data, setData] = useState('initial data');\n\n  useEffect(() => {\n    let cancel = false;\n    const asyncOp = async () => {\n      await sleep(10 * 1000);\n\n      if (cancel) {\n        return;\n      }\n\n      setData(props.updatedData);\n    };\n\n    asyncOp();\n\n    return () => {\n      cancel = true;\n    };\n  }, [props.updatedData]);\n\n  return (\n    <RenderCounter color=\"green\">\n      <div>{data}</div>\n    </RenderCounter>\n  );\n};\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note:"),' wait 10 seconds and look how data get updated. After that click few times on "re-render" button\nand the data will update once when the last re-render happens.')),Object(a.b)(xe,{mdxType:"UseEffectAsyncWithCleanupExample"}),Object(a.b)("p",null,"otherwise you might gat stale data, when the promise resolves later than expected."),Object(a.b)("p",null,"more detailed information in the following ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://dev.to/n1ru4l/homebrew-react-hooks-useasynceffect-or-how-to-handle-async-operations-with-useeffect-1fa8"}),"article"),"."))}Pe.isMDXComponent=!0;var Re=r.a.createContext({foo:0,bar:0},(function(e,t){return e.foo!==t.foo?1:0})),Te=function(e){var t=e.foo,n=e.bar;return r.a.createElement(v,{color:"blue"},r.a.createElement(Re.Provider,{value:{foo:t,bar:n}},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify({foo:t,bar:n},null,2))),r.a.createElement("div",null,e.children)))},Se=r.a.memo((function(){return r.a.createElement(Re.Consumer,{unstable_observedBits:1},(function(e){return r.a.createElement(v,{color:"green"},r.a.createElement("code",null,"ConsumerFoo (listens for ",r.a.createElement("code",null,"foo"),"):"," ",JSON.stringify(e,null,2)))}))})),Me=r.a.memo((function(){return r.a.createElement(Re.Consumer,{unstable_observedBits:2},(function(e){return r.a.createElement(v,{color:"red"},r.a.createElement("code",null,"ConsumerBar (listens for ",r.a.createElement("code",null,"bar"),"):"," ",JSON.stringify(e,null,2)))}))})),Fe=function(){var e=r.a.useState(0),t=Object(O.a)(e,2),n=t[0],a=t[1];return r.a.createElement(r.a.Fragment,null,r.a.createElement(Te,{foo:n,bar:1},r.a.createElement(Se,null),r.a.createElement(Me,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a(n+1)}},"Render example"))},ze=r.a.createContext({value:1}),De=function(e){var t=r.a.useMemo((function(){return{value:1}}),[]);return r.a.createElement(v,{color:"blue"},r.a.createElement(ze.Provider,{value:t},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify(t,null,2))),r.a.createElement("div",null,e.children)))},Ie=r.a.memo((function(){var e=r.a.useContext(ze);return r.a.createElement(v,{color:"green"},r.a.createElement("code",null,"Consumer: ",JSON.stringify(e,null,2)))})),Ue=function(){var e=C();return r.a.createElement(r.a.Fragment,null,r.a.createElement(De,null,r.a.createElement(Ie,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:e},"Render example"))},Ae=r.a.createContext(0),Je=r.a.createContext(0),We=function(e){var t=e.foo,n=e.bar;return r.a.createElement(v,{color:"blue"},r.a.createElement(Ae.Provider,{value:t},r.a.createElement(Je.Provider,{value:n},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify({foo:t,bar:n},null,2))),r.a.createElement("div",null,e.children))))},qe=r.a.memo((function(){var e=r.a.useContext(Ae);return r.a.createElement(v,{color:"green"},r.a.createElement("code",null,"ConsumerFoo: ",JSON.stringify(e,null,2)))})),Be=r.a.memo((function(){var e=r.a.useContext(Je);return r.a.createElement(v,{color:"red"},r.a.createElement("code",null,"ConsumerBar: ",JSON.stringify(e,null,2)))})),Xe=function(){var e=r.a.useState(0),t=Object(O.a)(e,2),n=t[0],a=t[1];return r.a.createElement(r.a.Fragment,null,r.a.createElement(We,{foo:n,bar:1},r.a.createElement(qe,null),r.a.createElement(Be,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a(n+1)}},"Render example"))},Ve=n(46),Le=n(47),He=Object(Ve.a)({foo:0,bar:0}),_e=function(e){var t=e.foo,n=e.bar;return r.a.createElement(v,{color:"blue"},r.a.createElement(He.Provider,{value:{foo:t,bar:n}},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify({foo:t,bar:n},null,2))),r.a.createElement("div",null,e.children)))},$e=r.a.memo((function(){var e=Object(Le.a)(He,(function(e){return e.foo}));return r.a.createElement(v,{color:"green"},r.a.createElement("code",null,"ConsumerFoo (listens for ",r.a.createElement("code",null,"foo"),"):"," ",JSON.stringify(e,null,2)))})),Ge=r.a.memo((function(){var e=Object(Le.a)(He,(function(e){return e.bar}));return r.a.createElement(v,{color:"red"},r.a.createElement("code",null,"ConsumerBar (listens for ",r.a.createElement("code",null,"bar"),"):"," ",JSON.stringify(e,null,2)))})),Ke=function(){var e=r.a.useState(0),t=Object(O.a)(e,2),n=t[0],a=t[1];return r.a.createElement(r.a.Fragment,null,r.a.createElement(_e,{foo:n,bar:1},r.a.createElement($e,null),r.a.createElement(Ge,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:function(){return a(n+1)}},"Render example"))},Ye=r.a.createContext({value:1}),Qe=function(e){var t={value:1};return r.a.createElement(v,{color:"blue"},r.a.createElement(Ye.Provider,{value:t},r.a.createElement("div",null,r.a.createElement("code",null,"Provider: ",JSON.stringify(t,null,2))),r.a.createElement("div",null,e.children)))},Ze=r.a.memo((function(){var e=r.a.useContext(Ye);return r.a.createElement(v,{color:"green"},r.a.createElement("code",null,"Consumer: ",JSON.stringify(e,null,2)))})),et=function(){var e=C();return r.a.createElement(r.a.Fragment,null,r.a.createElement(Qe,null,r.a.createElement(Ze,null)),r.a.createElement("hr",{style:{background:"transparent"}}),r.a.createElement("button",{onClick:e},"Render example"))},tt={};function nt(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},tt,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Context"),Object(a.b)("p",null,"This page covers only modern React Context API, i.e. ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/context.html"}),Object(a.b)("inlineCode",{parentName:"a"},"createContext()")),"."),Object(a.b)("h3",null,"Context behavior"),Object(a.b)("p",null,"All consumers that are descendants of a ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," will re-render whenever the ",Object(a.b)("inlineCode",{parentName:"p"},"Provider"),"\u2019s ",Object(a.b)("inlineCode",{parentName:"p"},"value")," prop changes. The propagation from ",Object(a.b)("inlineCode",{parentName:"p"},"Provider")," to its descendant consumers (including ",Object(a.b)("inlineCode",{parentName:"p"},".contextType")," on class components and ",Object(a.b)("inlineCode",{parentName:"p"},"useContext()")," hook) is not subject to the ",Object(a.b)("inlineCode",{parentName:"p"},"shouldComponentUpdate()")," method or ",Object(a.b)("inlineCode",{parentName:"p"},"React.memo()"),", so the consumer is updated even when an ancestor component skips an update."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"// \ud83d\udca1 React.memo will ignored\nconst Example = React.memo(props => {\n  // \ud83d\udca3 Updates will be triggered inside\n  const value = React.useContext(Context);\n\n  return <div />;\n});\n")),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Examples and info is taken from the official ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://reactjs.org/docs/context.html#caveats"}),"ReactJS")," documentation.")),Object(a.b)("p",null,"Context uses reference identity to determine when to re-render, there are some gotchas that could trigger\nunintentional renders in consumers when a provider\u2019s parent re-renders.\nFor example, the code below will re-render all consumers every time the Provider re-renders\nbecause a new object is always created for value:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"class Example extends React.Component {\n  state = { value: 1 };\n\n  render() {\n    const { children } = this.props;\n\n    // \u26d4 ({ value: 1 } === { value: 1 }) is false, so reference is different\n    return <Provider value={{ value: this.state.value }}>{children}</Provider>;\n  }\n}\n")),Object(a.b)("p",null,"To get around this, lift the value into the parent\u2019s state:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-tsx"}),"class Example extends React.Component {\n  state = { value: 1 };\n\n  render() {\n    const { children } = this.props;\n\n    return <Provider value={this.state.value}>{children}</Provider>;\n  }\n}\n")),Object(a.b)(et,{mdxType:"ContextUnmemoized"}),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},Object(a.b)("strong",{parentName:"p"},"Note"),": if context value is constant, then having a static value is fine, no even need to use ",Object(a.b)("inlineCode",{parentName:"p"},"useMemo()"),".")),Object(a.b)("h3",null,"Solution 1: Use memoized context value"),Object(a.b)("p",null,"If value is changing rarely is good option to memoize an object value with ",Object(a.b)("inlineCode",{parentName:"p"},"useMemo()")," hook."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Example = props => {\n  const { children, value } = props;\n  // \u2705 Now new `context` will be recreated only on `value` change\n  const context = React.useMemo(() => ({ value }), [value]);\n\n  return <Provider value={context}>{children}</Provider>;\n};\n")),Object(a.b)(Ue,{mdxType:"ContextMemoized"}),Object(a.b)("p",null,"For class components you can use ",Object(a.b)("inlineCode",{parentName:"p"},"this.state")," as was mentioned above."),Object(a.b)("h3",null,"Solution 2: Use separate contexts"),Object(a.b)("p",null,"This trick was ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://kentcdodds.com/blog/how-to-use-react-context-effectively"}),"described")," by Kent Dodds. The idea is to pass plain/memoized\nvalues in separate contexts to avoid useless notifications to subscribers."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Example = props => {\n  const { children } = props;\n\n  // \u2757 both values are plain and safe for shallow compare\n  const firstValue = 1;\n  const secondValue = 2;\n\n  return (\n    <FirstProvider value={firstValue}>\n      <SecondProvider value={secondValue}>{children}</SecondProvider>\n    </FirstProvider>\n  );\n};\n")),Object(a.b)(Xe,{mdxType:"ContextSeparate"}),Object(a.b)("h3",null,"Solution 3: Use context selectors"),Object(a.b)("p",null,Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://www.npmjs.com/package/@fluentui/react-context-selector"}),"@fluentui/react-context-selector")," implements ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/reactjs/rfcs/pull/119"}),"context selectors RFC"),". This package provides ",Object(a.b)("inlineCode",{parentName:"p"},"useContextSelector()")," hook allows to subscribe only to required updates."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const App = props => {\n  const { children } = props;\n  const { foo: 1, bar: 2 } = value;\n\n  return (\n    <Context.Provider value={value}>{children}</Context.Provider>\n  );\n};\n\nconst Consumer = props => {\n  // \u2705 Only updates that satisfy the selector will trigger the component's rerender\n  const foo = useContextSelector(Context, v => v.foo);\n\n  // do other things...\n}\n")),Object(a.b)(Ke,{mdxType:"ContextSelector"}),Object(a.b)("h3",null,"Solution 4: Experimental bits API"),Object(a.b)("p",null,"React provides an experimental API with ",Object(a.b)("inlineCode",{parentName:"p"},"calculateChangedBits")," & ",Object(a.b)("inlineCode",{parentName:"p"},"calculateChangedBits"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"function createContext<T>(defaultValue: T, calculateChangedBits?: (prev: T, next: T) => number): Context<T>;\nfunction useContext<T>(context: Context<T>, observedBits?: number|boolean): T;\n")),Object(a.b)("p",null,"Which allows to change default behavior of Context API and avoid useless rerenders. As it's experimental there are no official docs yet, check ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://medium.com/@leonardobrunolima/react-tips-context-api-performance-considerations-d964f3ad3087"}),"this article")," to get more details."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"changedBits === 0")," has a ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/facebook/react/blob/9b0bd43550206e04bfe9ca695e5981eff0e2d03f/packages/react-reconciler/src/ReactFiberBeginWork.js#L2304"}),"special handling")," in ",Object(a.b)("inlineCode",{parentName:"p"},"react-reconciler"),", so one of the most interesting tricks is to disable any consumer's updates:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"// \u2620\ufe0f Even is `value` will change updates will be silenced\nconst Context = React.createContext(value, () => 0);\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"changedBits")," API cannot be used with ",Object(a.b)("inlineCode",{parentName:"p"},"useContext()")," hook as will produce a warning:"),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"Warning: useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: 1.")),Object(a.b)("p",null,"The actual usage of ",Object(a.b)("inlineCode",{parentName:"p"},"changedBits")," is more complex:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"const Context = React.createContext(value, (prev, next) => {\n  // \ud83d\udca1 This context handles only changes on `value.foo`\n  if (prev.foo !== next.foo) {\n    return 1;\n  }\n\n  // \ud83d\udece\ufe0f Will silence all other updates, i.e. they will not be propogated to context consumers\n  return 0;\n});\n\nconst App = props => {\n  const { children } = props;\n  const { foo: 1, bar: 2 } = value;\n\n  return (\n    <Context.Provider value={value}>{children}</Context.Provider>\n  );\n};\n\nconst Consumer = props => {\n  // \ud83e\uddf1 Listen only for `1` bit changes\n  return <Context.Consumer unstable_observedBits={1}>{value => null}</<Context.Consumer>\n}\n")),Object(a.b)(Fe,{mdxType:"ContextChangedBits"}),Object(a.b)("p",null,"There is also a lot of custom context/global state implementations, comparison\nfor Concurrent mode ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://github.com/dai-shi/will-this-react-global-state-work-in-concurrent-mode"}),"available there"),"."))}nt.isMDXComponent=!0;var at={};function ot(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},at,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"State Immutability in React, why it is important, and how to achieve it using Immer"),Object(a.b)("p",null,"React ",Object(a.b)("em",{parentName:"p"},"props")," and ",Object(a.b)("em",{parentName:"p"},"state")," are readonly by contract; it is, however, very easy to break this contract\nand introduce issues that are difficult to debug. In order to prevent these issues it is advised not\nto mutate state unless necessary. If non-trivial mutation of the current state is unvoidable, it is\nadvised to use an immutability helper called Immer."),Object(a.b)("p",null,"In the text below we start with a piece of code\nthat doesn't work, we transform it into code that works, but is error-prone and unreadable, and eventually\nwe reach the state of well readable and easily maintainable code. As we go over these phases\nwe gradually build a case for using Immer."),Object(a.b)("h3",null,"State mutation outside of setState mechanism"),Object(a.b)("p",null,"React ",Object(a.b)("em",{parentName:"p"},"state")," is declared readonly, but that only means that the ",Object(a.b)("em",{parentName:"p"},"reference")," to it is constant. This\neffectively protects primitives from being changed, but it doesn't protect objects. The only sound\nmeans of state change in React is the ",Object(a.b)("em",{parentName:"p"},"setState")," method and any code that asserts it is correct in doing so.\nIn the example below, the ",Object(a.b)("em",{parentName:"p"},"sumData"),' function rightfully asserts that the state object will not change\nand based on that it caches its output based on the state object\'s internal field "data".'),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState({ data: [0, 0] });\n\n  // Assert state immutability.\n  const data = state.data;\n  const sumData = React.useCallback(\n    () => data.reduce((acc, val) => acc + val, 0),\n    [data]\n  );\n\n  const run = () => {\n    // State mutated.\n    state.data = [1, 1];\n    // Sum is out of sync.\n    state.data.push(sumData());\n    state.data.push(sumData());\n    state.data.push(sumData());\n    setState({ data: state.data });\n  };\n")),Object(a.b)("p",null,"However, the ",Object(a.b)("em",{parentName:"p"},"run")," function changes the state object -- its internal field ",Object(a.b)("em",{parentName:"p"},"data")," now points to a\ndifferent address. ",Object(a.b)("em",{parentName:"p"},"sumData")," captures the original address (that wasn't supposed to change), and therefore\nit will sum the original data."),Object(a.b)("p",null,"The logical step in rectifying this seems to be to make ",Object(a.b)("em",{parentName:"p"},"sumData")," capture the entire state -- since it is\nreadonly we will be sure that we always refer to the correct address. It also seemingly makes sense not to construct\na new state object in ",Object(a.b)("em",{parentName:"p"},"run")," since we only change a single field inside of it:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState({ data: [0, 0] });\n\n  // Assert state immutability.\n  const sumData = React.useCallback(\n    () => state.data.reduce((acc, val) => acc + val, 0),\n    [state]\n  );\n\n  const run = () => {\n    // State mutated.\n    state.data = [1, 1];\n    // Sum is in sync.\n    state.data.push(sumData());\n    state.data.push(sumData());\n    state.data.push(sumData());\n    setState(state);\n  };\n")),Object(a.b)("p",null,"The issue with this change is that now it doesn't work at all, because React asserts that since the\naddress of the state object hasn't changed, the object itself hasn't changed, and it will ignore the\nsetState call. The obvious solution is to copy the object:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),"export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState({ data: [0, 0] });\n\n  // Assert state immutability.\n  const sumData = React.useCallback(\n    () => state.data.reduce((acc, val) => acc + val, 0),\n    [state]\n  );\n\n  const run = () => {\n    state.data = [1, 1];\n    // Contract violation.\n    state.data.push(sumData());\n    state.data.push(sumData());\n    state.data.push(sumData());\n    setState({...state});\n  };\n")),Object(a.b)("p",null,'Now the code will work. The issue with this code, however, is that it is breaking the immutability contract\nwith React and that it is prone to error. If the state object were to consist of multiple nested fields,\nwe would have to make sure that the object is copied properly to form a new state. Since there is no native\nconcept of "deep copy" in javascript, doing this can be rather cumbersome:'),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState(getCumbersomeState());\n\n  const getStateString = React.useCallback(() => JSON.stringify(state), [\n    state\n  ]);\n\n  const updateJillsStreet = () => {\n    // It is easy to get lost in this sea of spread operators and brackets.\n    setState(prevState => ({\n      people: [\n        { ...prevState.people[0] },\n        {\n          ...prevState.people[1],\n          addresses: [\n            {\n              ...prevState.people[1].addresses[0],\n              street: `Street ${Math.random()}`\n            }\n          ]\n        }\n      ]\n    }));\n  };\n\n  return (\n    <div className="App">\n      <div>{getStateString()}</div>\n      <div>\n        <button onClick={updateJillsStreet}>updateJillsStreet</button>\n      </div>\n    </div>\n  );\n};\n')),Object(a.b)("h3",null,"Immer.js to the rescue"),Object(a.b)("p",null,"And that is when Immer.js comes to the rescue. Immer.js uses ES6 proxies (note that when transcompiled to ES5\nit will become much slower) to record changes to a so called ",Object(a.b)("em",{parentName:"p"},"draft")," object during the execution of the ",Object(a.b)("em",{parentName:"p"},"produce"),"\nfunction and then project them onto a new object that becomes the new state. The ",Object(a.b)("em",{parentName:"p"},"draft")," object is based on the existing\nstate that is passed to the ",Object(a.b)("em",{parentName:"p"},"produce")," function along with the draft callback. The following snippet demonstrates\nhow we go from cumbersome, ugly, and ureadable to straightforward, beautiful, and well readable:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'export const Component: React.FunctionComponent = props => {\n  const [state, setState] = React.useState(getCumbersomeState());\n\n  const getStateString = React.useCallback(() => JSON.stringify(state), [\n    state\n  ]);\n\n  const updateJillsStreet = () => {\n    setState(\n      produce(state, _draft => {\n        _draft.people[1].addresses[0].street = `Street ${Math.random()}`;\n      })\n    );\n  };\n\n  return (\n    <div className="App">\n      <div>{getStateString()}</div>\n      <div>\n        <button onClick={updateJillsStreet}>updateJillsStreet</button>\n      </div>\n    </div>\n  );\n};\n')),Object(a.b)("p",null,"This can be further simplified by using the ",Object(a.b)("em",{parentName:"p"},"use-immer")," npm package that provides us with a hook\nthat combines the native ",Object(a.b)("em",{parentName:"p"},"React.useState")," and Immer's ",Object(a.b)("em",{parentName:"p"},"produce"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-jsx"}),'export const Component: React.FunctionComponent = props => {\n  const [state, setState] = useImmer(getCumbersomeState());\n\n  const getStateString = React.useCallback(() => JSON.stringify(state), [\n    state\n  ]);\n\n  const updateJillsStreet = () => {\n    setState(_draft => {\n      _draft.people[1].addresses[0].street = `Street ${Math.random()}`;\n    });\n  };\n\n  return (\n    <div className="App">\n      <div>{getStateString()}</div>\n      <div>\n        <button onClick={updateJillsStreet}>updateJillsStreet</button>\n      </div>\n    </div>\n  );\n};\n')),Object(a.b)("p",null,"In the newly created state, fields that didn't change during the execution of the draft callback\nwill be referentially equal to the fields in the original state. Only fields that were changed\nin the draft and the root object will be new objects."),Object(a.b)("h3",null,"Resources"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://immerjs.github.io/immer/docs/introduction"}),"https://immerjs.github.io/immer/docs/introduction"))))}ot.isMDXComponent=!0;var rt={};function ct(e){var t=e.components,n=Object(d.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},rt,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",null,"Useful Links"),Object(a.b)("h3",null,"Common Topics"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactjs.org/docs/getting-started.html"}),"React JS")," - the official ReactJS documentation."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://github.com/typescript-cheatsheets/react-typescript-cheatsheet"}),"React+TypeScript Cheatsheets")," - Cheatsheets for experienced React developers getting started with TypeScript"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://dev.to/codeartistryio/the-react-cheatsheet-for-2020-real-world-examples-4hgg"}),"The React Cheatsheet for 2020 \ud83d\udcc4\u202c")," - The React Cheatsheet for 2020 \ud83d\udcc4\u202c (+ real-world examples)."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://reactpatterns.com/"}),"React Patterns")," - Get the latest React patterns, tips, and tricks right to your inbox.")),Object(a.b)("h3",null,"Hooks"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",Object.assign({parentName:"li"},{href:"https://dev.to/n1ru4l/homebrew-react-hooks-useasynceffect-or-how-to-handle-async-operations-with-useeffect-1fa8"}),Object(a.b)("inlineCode",{parentName:"a"},"useEffect()"))," with async call.")))}ct.isMDXComponent=!0;var st=function(){return r.a.createElement(m.a,null,r.a.createElement("div",{className:"wrapper"},r.a.createElement("header",null,r.a.createElement("h1",null,"React Patterns")),r.a.createElement("div",{className:"main"},r.a.createElement("aside",null,r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(m.b,{to:"/"},"Overview")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/components"},"Components"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(m.b,{to:"/class-component"},"Class Component")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/pure-component"},"Pure Component")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/function-component"},"Function Component")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/method-component"},"Method Component")))),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/hooks"},"Hooks"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(m.b,{to:"/hook-use-effect"},"useEffect")))),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/context"},"Context")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/immutability"},"Immutability")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/links"},"Links")))),r.a.createElement("main",null,r.a.createElement(r.a.Suspense,{fallback:r.a.createElement("div",null,"Loading...")},r.a.createElement(b.c,null,r.a.createElement(b.a,{path:"/components",component:H}),r.a.createElement(b.a,{path:"/class-component",component:K}),r.a.createElement(b.a,{path:"/pure-component",component:ee}),r.a.createElement(b.a,{path:"/function-component",component:oe}),r.a.createElement(b.a,{path:"/method-component",component:ue}),r.a.createElement(b.a,{path:"/hooks",component:ge}),r.a.createElement(b.a,{path:"/hook-use-effect",component:Pe}),r.a.createElement(b.a,{path:"/context",component:nt}),r.a.createElement(b.a,{path:"/immutability",component:ot}),r.a.createElement(b.a,{path:"/links",component:ct}),r.a.createElement(b.a,{exact:!0,path:"/",component:j}))))),r.a.createElement("footer",null,r.a.createElement("div",{className:"git-hub"},r.a.createElement("a",{href:"https://github.com/smykhailov/react-patterns"},r.a.createElement("img",{src:"GitHub-Mark-32px.png",alt:"GitHub Logo"}))),r.a.createElement("div",{className:"copyright"},r.a.createElement("a",{href:"https://github.com/smykhailov/react-patterns"},"React Patterns")))))},lt=n(22),pt=(n(42),{code:function(e){var t=e.className,n=void 0===t?"language-jsx":t,a=e.children,o=void 0===a?"":a,c=n.replace("language-",""),s=o.replace(/\n$/,"");return r.a.createElement(r.a.Fragment,null,r.a.createElement("style",null,".prism-code .token.plain { display: inline-block; }"),r.a.createElement("style",null,".prism-code .token.comment { font-style: normal; }"),r.a.createElement(lt.a,Object.assign({},lt.b,{code:s,language:c,theme:void 0}),(function(e){var t=e.className,n=e.style,a=e.tokens,o=e.getLineProps,c=e.getTokenProps;return r.a.createElement("pre",{className:t,style:Object(f.a)({},n,{padding:3})},a.map((function(e,t){return r.a.createElement("div",o({line:e,key:t}),e.map((function(e,t){return r.a.createElement("span",c({token:e,key:t}))})))})))})))}});Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));n(43);new p.a(u.a).injectStyles(),s.a.render(r.a.createElement(a.a,{components:pt},r.a.createElement(st,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()}))}},[[31,1,2]]]);
//# sourceMappingURL=main.1b571033.chunk.js.map